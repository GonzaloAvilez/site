{% extends "shop/home.html" %}
{% load staticfiles %}
{% load thumbnail %}
{% load i18n %}
{% load crispy_forms_tags %}

{% block title %}{{ block.super }}Virtual Reality{% endblock %}


{% block styles %}
    <style>
       #custom {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
            position: fixed;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: 0;
        }
    </style>
{% endblock styles %}

{% block container %}
<body id="custom">
    <canvas id="renderCanvas"></canvas>

    <button class="btn btn-large btn-default" id="button" style="position: absolute;top: 70px;margin-left: 1px;">Add Rack ||</button>
    <button class="btn btn-large btn-default" id="rotation-button" style="position: absolute;top: 110px;margin-left: 1px;">Add Rack T</button>

 </body>
{% endblock container %}




{% block scripts%}

<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
<!--<script src="{% static 'baby/babylon.js' %}"></script>-->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>


var scene;
var startingPoint;
var currentMesh;



    if (BABYLON.Engine.isSupported()) {
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);


        function MyLoadingScreen( /* variables needed, for example:*/ text) {
          //init the loader
          this.loadingUIText = text;
        }
            MyLoadingScreen.prototype.displayLoadingUI = function() {
              alert(this.loadingUIText);
            };
            MyLoadingScreen.prototype.hideLoadingUI = function() {
              alert("Model Loaded!");
            };

            var loadingScreen = new MyLoadingScreen("Loading model...!! Instructions: press Enter to rotate Rack or clicking in buttons");
            engine.loadingScreen = loadingScreen;


        // Resize window canvas for well responsiv remder
        window.addEventListener("resize", function () {
        engine.resize();
        });


        var warehouse_rack = "warehouse_rack.babylon";





        BABYLON.SceneLoader.Load("{% static 'site/img/warehouse/' %}", "warehouse_textured.babylon", engine, function (newScene) {
            scene = newScene;
            console.log(newScene);



            BABYLON.SceneLoader.ImportMesh("", "{% static 'site/img/warehouse/' %}", warehouse_rack , newScene, function (newMeshes) {

                        newMeshes.position = new BABYLON.Vector3(100,100, 60);// position mesh in your scene
                         // var fridge = newScene.getMeshByName("fridge");


                    });





           // var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);
           //  camera.setPosition(new BABYLON.Vector3(20, 200, 400));

           //  camera.lowerBetaLimit = 0.1;
           //  camera.upperBetaLimit = (Math.PI / 2) * 0.99;
           //  camera.lowerRadiusLimit = 150;





            newScene.executeWhenReady(function () {
                newScene.clearColor = new BABYLON.Color3(0, 0, 0);
                newScene.specularIntensity = 1;



                // *************************************Managing 3d objects******************************************
                newScene.gravity = new BABYLON.Vector3(0, -0.9, 0);
                newScene.collisionsEnabled = true;
                var warehouse = newScene.getMeshByName("warehouse");
                var rack  = newScene.getMeshByName("rack");
                console.log(warehouse);
                console.log(rack);
                warehouse.checkCollisions = true;
                rack.checkCollisions = true;
                // newScene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
                newScene.enablePhysics();
                // rack.physicsImpostor = new BABYLON.PhysicsImpostor(rack, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, newScene);
                 // take button from html tag and render new 3d element jQuery
                $('#button').click(function () {
                    // clone for rack element
                    var rack_clone = rack.clone("rack");
                    rack_clone.position = new BABYLON.Vector3(0, 0, 0);
                    rack_clone.checkCollisions = true;

                });
                // take button from html tag and render new 3d element pure JavaScript
                // document.getElementById("button").addEventListener("click",function () {
                //     var sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 2, scene);
                //     sphere.position.y = 1;
                // });
                 $('#rotation-button').click(function () {
                    // clone for rack element
                    var rack_clone2 = rack.clone("rack");
                    rack_clone2.position = new BABYLON.Vector3(0, 0, 0);
                    rack_clone2.rotation.y = Math.PI/2;
                    rack_clone2.checkCollisions = true;

                });



                // *************************************Lights******************************************

                var light = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -3, 0), newScene);
                console.log(light);
                light.intensity = 0.5;
                light.diffuse = new BABYLON.Color3(1, 1, 1);

                var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
                  shadowGenerator.getShadowMap().renderList.push(rack);
                  shadowGenerator.useBlurVarianceShadowMap = true;
                  warehouse.receiveShadows = true;


                // *************************************Camera******************************************

                 var camera = new BABYLON.ArcRotateCamera("UniversalCamera", 0, 0, 10, new BABYLON.Vector3(0, 1, -15), newScene);
                     camera = newScene.activeCamera;
                     camera.lowerBetaLimit = 0.1;
                     camera.upperBetaLimit = (Math.PI / 2) * 0.99;
                     camera.lowerRadiusLimit = 150;
                     // camera.checkCollisions = true;





                 var getWarehousePos = function () {
                // Use a predicate to get position on the warehouse
                    var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == warehouse; });
                    if (pickinfo.hit) {
                        return pickinfo.pickedPoint;
                    }

                    return null;
                }
                var onPointerDown = function (evt) {
                    if (evt.button !== 0) {
                        return;
                    }
                        var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh !== warehouse; });
                        if (pickInfo.hit) {
                            currentMesh = pickInfo.pickedMesh;
                            startingPoint = getWarehousePos(evt);

                            if (startingPoint) {
                                setTimeout(function () {
                                    camera.detachControl(canvas);
                                }, 0);
                            }
                        }
                }

                var onPointerUp = function () {
                    if (startingPoint) {
                        camera.attachControl(canvas, true);
                        startingPoint = null;
                        return;
                    }
                }

                var onPointerMove = function (evt) {
                    if (!startingPoint) {
                        return;
                    }
                    var current = getWarehousePos(evt);
                    if (!current) {
                        return;
                    }
                    var diff = current.subtract(startingPoint);
                    currentMesh.position.addInPlace(diff);
                    startingPoint = current;
                    // press enter to rotate currentMesh in movement
                    $(document).keypress(function(e) {
                        if(e.which == 13) {
                            var dynamic_rotate = currentMesh.rotation.y
                            currentMesh.rotation.y = dynamic_rotate+Math.PI/2;;
                        }
                    });

                }

                canvas.addEventListener("pointerdown", onPointerDown, false);
                canvas.addEventListener("pointerup", onPointerUp, false);
                canvas.addEventListener("pointermove", onPointerMove, false);
                engine.onDispose = function () {
                    canvas.removeEventListener("pointerdown", onPointerDown);
                    canvas.removeEventListener("pointerup", onPointerUp);
                    canvas.removeEventListener("pointermove", onPointerMove);
                }

                // Once the scene is loaded, just register a render loop to render it
                engine.runRenderLoop(function() {
                    newScene.render();
                });
            });
        },

        function (progress) {
            // To do: give progress feedback to user
        }

    ); //ending BAB

    } //if  satement



</script>

<script>
    $('.container').empty();            //Hidde footer container from base.html in order to resize correctly Screens
     $('.navbar-default').empty();
</script>

{% endblock scripts%}



